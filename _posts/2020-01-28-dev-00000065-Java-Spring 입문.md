---
date: 2020-01-28 22:00:00
layout: post
title: Java Spring 입문
subtitle: Spring Fw 사용을 위한 기초 
description: "Current JDK : == JDK 1.8.0_231(64bit)"
image: ../assets/img/postsimg/R_main_00000003.png
optimized_image: ../assets/img/postsimg/R_op_00000003.png
category: coding
tags:
  - Eclipse
  - Java
  - Lambda
  - vsCode
  - Spring
  - Web
  - REST
author: thiagorossener
# image:760*400
# optimized_image:380*200
---
# Spring은 엔터프라이즈 급의 웹 애플리케이션 개발을 위한 라이브러리를 제공하는 프레임워크 이다.

<br>

- 특징, 장점
  - Lightweight Container (가벼운 컨테이너)
  - Dependency Injection Pattern 지원
  - AOP(Aspect Oriented Programming) 지원
  - POJO(Plain Old Java Object) 지원
  - 일관된 Transaction 처리 방법 제공
  - 다양한 Persistance 관련 API 제공 (JDBC, iBATIS, JPA, JDO 등...)
  - Restlet과 얀동 가능

- 관련 WebSite
  - http://springframework.org/

- 맺음말
  - Spring 프레임워크는 최근 가장 많이 사용되고 있는 웹 프레임 워크
  - 최근 주목받고 있는 REST 아키텍쳐의 자바 구현체인 Restlet과 같이 사용할 수 있다.

- 공식 웹사이트 튜토리얼
  - https://www.tutorialspoint.com/spring/spring_environment_setup.htm
  - https://www.popit.kr/%EC%8B%A0%EC%9E%85-%EA%B0%9C%EB%B0%9C%EC%9E%90-%ED%95%99%EC%83%9D%EC%9D%84-%EC%9C%84%ED%95%9C-spring-mvc-setting-1%ED%8E%B8/

- 설치 순서
  - https://maven.apache.org/download.cgi 접속 -> Link 에서 OS에 맞게 메이븐 다운로드 -> C드라이브 root에 압축해체 -> maven폴더 경로로 환경변수 설정 -> cmd 에서 mvn -v 확인해봄
  - STS 다운로드 -> https://spring.io/tools3/sts/all 맞는 버전 다운로드 -> C드라이브 root폴더에 압축해체 -> STS실행
  - Lombok설치 -> https://projectlombok.org/download -> jar파일 다운로드후 더블클릭 -> 인스톨 되어있는 이클립스 및 STS툴 자동탐색됨 -> 이후 [install/update] 버튼 클릭
  - curl설치 -> https://curl.haxx.se/download.html 에서 win64 - generic 항목 찾아봄 -> 200129기준 curl-7.68.0-win64-mingw.zip 다운로드 후 C드라이브 root 폴더에 압축해제 -> curl bin경로 환경변수 셋팅 -> curl -V으로 정상설치 확인

## Chapter.01 기본 프로젝트 시작

- 기본 프로젝트 만들기
  - cmd창 -> 기본 템플릿 생성 명령 :: mvn -B archetype:generate -DgroupId=com.example -DartifactId=hajiboot -Dversion=1.0.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-quickstart -> 이 작업은 스프링 부트와는 관계없는 작업 일반적인 절차임. -> cmd상 현재 디렉토리에 생성됨.
  - cd hajiboot의 디렉토리로 이동
- pom.xml 설정하기 
  - 스프링 부트를 사용하는 데 필요한 설정 내용을 메이븐의 의존 관계 정의 파일에 입력합니다.

## pom.xml 설정 파일 에 새로 입력한 소스 목록이다.

> 새로 입력한 부분 주석 부분이 원래 존재하던 소스 말고 새로 입력한 부분이다.

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId>
  <artifactId>hajiboot</artifactId>
  <packaging>jar</packaging>
  <version>1.0.0-SNAPSHOT</version>
  <name>hajiboot</name>
  <url>http://maven.apache.org</url>
  
  <!-- 새로 입력한 부분5 -->
  <properties>
    <java.version>1.8</java.version>
  </properties>
  <!-- end -->

  <!-- 새로 입력한 부분1 -->
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.2.4.RELEASE</version>
  </parent>
  <!-- end -->

  <dependencies>
    <!-- 새로 입력한 부분2 --> 
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!-- end -->

    <!-- 새로 입력한 부분3 -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
    <!-- end -->

    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>

    <!-- 새로 입력한 부분4 -->
    <build>
      <plugins>
        <plugin>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
      </plugins>
    </build>
    <!-- end -->
</project>
```

| 번호     | 설명                                                                                                                                                                                      |
|----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1번 부분 | 스프링 부트의 설정 정보를 상속합니다.<br><br>여기서 지정한 버전이 스프링 부트의 버전이 됩니다.<br><br>스프링 부트의 버전을 올리려면 <version>태그 안에 있는 설정 값을 변경합니다.         |
| 2번 부분 | 스프링 부트로 웹 어플리케이션을 만들 떄 참조할 기본 라이브러리 정보를 설정합니다.<br><br>웹 어플 제작에 필요한 스프링 프레임워크 관련 라이브러리와 서드파티 라이브러리를 이용할 수 있게됨 |
| 3번 부분 | 스프링 부트로 제작하는 과정에서 유닛 테스트에 필요한<br>라이브러리 참조 정보를 설정합니다(일반적인 라이브러리 이므로 추가)                                                                |
| 4번 부분 | 스프링 부트로 제작한 애플리케이션을 간단하게 빌드하고 실행하기 위해 메이븐 플로그인을 설정합니다.                                                                                         |
| 5번 부분 | 자바 8을 사용할 수 있도록 설정합니다.  

- mvn dependency:tree 명령어로 위 설정한 내용만으로도 얼마나 많은 라이브러리를 사용할 수 있게 되는지 확인해봅시다.

## Chapter.02
- STS로 Spring 개발하기
  - 전에 만들어둔 소스 가져오기 -> STS -> file -> import -> maven -> Existing Maven Projects -> 소스폴더 클릭후 xml추가 -> STS 왼쪽에 프로젝트 생성 완료됨. -> src/main/java -> com.example.App.java 오른쪽 클릭후 Spring Boot App 실행 하면 됨.

> HelloWorld 띄워보기

```java
// App.java

package com.example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Hello world!
 *
 */

@RestController // 이 클래스가 웹 에서 요청을 받아들이는 컨트롤러 클래스임을 나타냄
@EnableAutoConfiguration // 스프링 부트에서 대단히 중요한 요소임 다양한 설정이 자동으로 수행되고 기존의 스프링 어플에 필요했던 설정 파일들이 필요 없게 됨
// @SpringBootApplication // Configuration, enableautoconfig, componentScan 등 프로그래머가 자주 사용하는 어노테이션을 기본값 으로 결합한 어노테이션 SpringBoot 버전 1.2.0 부터 사용 가능.
public class App 
{
	
	@RequestMapping // 이 메서드가 HTTP요청을 받아들이는 메소드임을 나타냄
	String home() {
		return "Hello World!"; // http응답 반환 컨트롤러 어노테이션 클래스에 속한 메서드에서 문자열을 반환하면 해당 문자열이 그대로 HTTP 응답이 되어 출력됨.
	}
	
    public static void main( String[] args )
    {
       // 스프링부트 어플을 실행하는 데 필요한 처리를 main() 메소드 안에 작성
       // @EnableAutoConfiguration 어노테이션이 붙은 클래스를 아래 클래스 메서드의 첫번째 인자로 지정합니다.
       SpringApplication.run(App.class, args);
    }
}
```
- 스프링 부트 템플릿 프로젝트를 생성해 주는 SPRING INITIALIZR 라는 서비스도 있습니다. 웹 브라우저에서 필요한 요소들을 선택하면 템플릿 프로젝트를 zip 파일로 다운로드할 수 있게 해주는 서비스 입니다.
- 코드수정 내용을 바로 반영하기 위해서 Spring loaded라는 편리한 유틸리티를 사용한다. 아래는 로디드를 사용하기 위한 pom.xml의 양식이다.
  - https://collinsd.tistory.com/284 사이트 참조
  - https://github.com/spring-projects/spring-loaded 다운로드
  - C로컬 최상위 루트에 압축 해제
  - SpringBoot App arguments(적용 프로젝트 선택후) 에 다운받은 loaded.jar을 설정
    - -javaagent:{jar디렉토리}/springloaded-1.2.8.RELEASE.jar -noverify
    - 프로젝트 오른쪽 클릭 -> maven build... 클릭후 Goals에 spring-boot:run적용\
    - 그 후 아래 Pom 파일에 요소 추가

```xml
<!-- 빌드 안에다가 입력 해야 한다-->
	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				
				<!-- 추가내용 -->
				<dependencies>
					<dependency>
						<groupId>org.springframework</groupId>
						<artifactId>springloaded</artifactId>
						<version>1.2.8.RELEASE</version>
					</dependency>
				</dependencies>
				<!-- 추가 끝 -->
			</plugin>
		</plugins>
	</build>
```

## Chapter.03 스프링 프레임워크에서 구현하는 DI
- DI(Dependency Injection)란 의존성 주입의 줄임말이며, 스프링 프레임워크의 핵심 기술입니다.
- DI를 사용하면 클래스 사이의 의존 관계를 자동으로 구성
- DI 컨테이너는 인스턴스를 관리합니다. DI 컨테이너가 인스턴스를 생성하고 그 인스턴스에 필요한 인스턴스를 설정하여 애플리케이션에 반환 합니다.
- 장점
  - 인스턴스의 스코프를 제어할 수 있다(ex. 싱글톤 객체로 생성할지 매번 새로 생성할지 등...)
  - 인스턴스의 Life Cycle을 이벤트로 제어할 수 있다.(생성과 소멸 이벤트 처리)
  - 공통 처리를 포함할 수 있다.(트랜잭션 관리나 로깅처리)
  - 객체 사이의 의존 관계가 느슨해지므로 유닛 테스트를 하기 쉬워집니다.

## Chapter.03-1 맛보기 만들기

```java
// 인터페이스 생성
public interface Calculator {
	public int calc(int a, int b);
}

/****************************************/

// Calculator 구현 클래스
public class AddCalculator implements Calculator {

	@Override
	public int calc(int a, int b) {
		return a + b;
	}
}
```

- 위순서대로 설정후 인터페이스 선언후 AddCalculator 클래스 로 인터페이스를 구현해준다.
- Calculator 인터페이스에 어떤 실제 기능(Bean)을 제공할지는 DI 컨테이너가 관리하도록 구현합니다.
- DI 컨테이너가 Bean을 관리할 수 있도록 Bean 정의 파일을 만듭니다. 스프링 프레임워크에는 크게 다음 두가지 Bean 정의 파일 형식이 있습니다.
  - XML 정의
  - 자바 클래스(Java Config) 정의
- 두번째 자바 클래스 정의는 스프링 프레임워크 버전 3부터 도입된 형식이며, 이 책에서는 이 빙법을 사용하려 설명 합니다.

## AppConfig 클래스

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration // 이 클래스가 JavaConfig용 클래스임을 컴파일러에게 알립니다.
public class AppConfig {
	@Bean // DI컨테이너가 관리할 Bean을 생성하는 메서드에는 이 어노테이션을 붙힙니다.
	public Calculator calculator() {
		// @Bean 어노테이션으로 인해 기본적으로 메서드 이름이 Bean이름이 됩니다.
		// 또한 기본적으로 이 메소드가 생성한 이름은 싱글톤 형태로 DI컨테이너 별로 한 개만 생성 됩니다.
		return new AddCalculator(); // Calculator 타입의 싱글톤 객체
	}
}
```

- 완성된 Bean정의 파일인 AppConfig를 읽어들여 어플리케이션에서 구현객체를 실행할 Entry(출입 할 수 있는 기회, 가입 할 수 있는 기회) point를 만들겠습니다.

## App 클래스

```java
import java.util.Scanner;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.Import;

@SpringBootApplication
@Import(AppConfig.class) // javaConfig흫 읽어들이기 위해 @Cunfiguration 어노테이션이 붙은 클래스를 지정
public class App {
	public static void main(String[] args) {
		
		// try() 안에 정의하는 방법을 try-with-resources이다. 처리가 끝나면 
		// 자동으로 close() 메소드가 호출되어  DI컨테이너가 소멸하고 어플리케이션을 종료합니다.
		try(ConfigurableApplicationContext context = 
				SpringApplication.run(App.class, args)) {
			
			// SpringApplication.run으로 @EnableAutoConfiguration을 붙힌 클래스를 지정
			// 이 메소드의 반환값은 DI컨테이너의 본체인 타입으로 반환 받습니다.
			Scanner sc = new Scanner(System.in); // 데이터 입력
			System.out.println("Enter 2 number like 'a b' : ");
			int a = sc.nextInt();
			int b = sc.nextInt();
			
			// getBean() 메소드를 이용하여 DI 컨테이너에서 Calculator 인스턴스를 반환 받는다
			// 실제 인스턴스는 DI가 알아서 찾아주므로 어플리케이션 쪽에서는 신경쓰지 않아도 됩니다.
			Calculator calculator = context.getBean(Calculator.class);
			int result = calculator.calc(a, b);
			System.out.println("result = " + result);
			
			sc.close(); // Scanner 닫기
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

- 위 처럼 DI컨테이너를 Import로 지정해주고 DI컨테이너를 관리한다면 어플리케이션 안에 있는 모듈 사이의 의존성이 느슨해지고 독립성이 커집니다.

## Chapter.03-2 어플리케이션 추상화하기

- 이제 어플리케이션을 조금 더 추상화해보자 Calculator의 인자를 만들기 위해서 ArgumentResolver 인터페이스를 만듭니다.

```java
// 인터페이스 부분
import java.io.InputStream;

public interface ArgumentResolver {
	
	Argument resolve(InputStream is);
}

// Argument 클래스 구현 부분
import lombok.Data;
import lombok.RequiredArgsConstructor;

@Data // class파일을 생성할때 각 필드의 setter/getter, toString, equals, hashCode 메소드가
// 생성되므로 소스코드가 간결해진다. 아래 필드는 final형태라 setter/getter가 생성되지 않는다.
@RequiredArgsConstructor
public class Argument {
	private final int a;
	private final int b;
}
```

- 자바 클래스를 쉽게 작성하기 위한 Lombok을 사용합니다. 다음과 같이 pom에 추가 합니다.
```java
  <dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.10</version>
    <scope>provided</scope>
  </dependency>
```

- 앞에서 한 것처럼 Scanner로 인자를 생성해서 반환하는 클래스(ArgumentResolver의 본체)를 만듭니다.

```java
// ArgumentResolver의 본체
import java.io.InputStream;
import java.util.Scanner;

// Resolver : 결의, 결심, 결단
public class ScannerArgumentResolver implements ArgumentResolver{
	
	@Override
	public Argument resolve(InputStream is) {
		Scanner scanner = new Scanner(is);
		
		int a = scanner.nextInt();
		int b = scanner.nextInt();
		return new Argument(a, b);
	}
}
```

- 위 본체를 DI컨테이너가 관리하게 끔 Bean을 AppConfig에 생성해줌
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration // 이 클래스가 JavaConfig용 클래스임을 컴파일러에게 알립니다.
public class AppConfig {
	
	@Bean // DI컨테이너가 관리할 Bean을 생성하는 메서드에는 이 어노테이션을 붙힙니다.
	public Calculator calculator() {
		...위 AppConfig와 동일
	}
	
  // 이 부분을 추가해줌 의존성을 낮추고 독립성을 높힘
	@Bean // DI컨테이너가 관리할 Bean을 생성하는 메서드
	ArgumentResolver argumentResolver() {
		return new ScannerArgumentResolver();
	}
}
```

- 이제 DI컨테이너 에서 수정을 거친다

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.Import;

@SpringBootApplication
@Import(AppConfig.class) // javaConfig흫 읽어들이기 위해 @Cunfiguration 어노테이션이 붙은 클래스를 지정
public class App {
	public static void main(String[] args) {
		
		// try() 안에 정의하는 방법을 try-with-resources이다. 처리가 끝나면 
		// 자동으로 close() 메소드가 호출되어  DI컨테이너가 소멸하고 어플리케이션을 종료합니다.
		try(ConfigurableApplicationContext context = 
				SpringApplication.run(App.class, args)) {
			
			// SpringApplication.run으로 @EnableAutoConfiguration을 붙힌 클래스를 지정
			// 이 메소드의 반환값은 DI컨테이너의 본체인 타입으로 반환 받습니다.
			System.out.println("Enter 2 numbers like 'a b' : ");
			ArgumentResolver ar = context.getBean(ArgumentResolver.class);
			
			Argument argument = ar.resolve(System.in);
			Calculator calculator = context.getBean(Calculator.class);
			
      // @Data 어노테이션
			int result = calculator.calc(argument.getA(), argument.getB());
			System.out.println("result = " + result);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```